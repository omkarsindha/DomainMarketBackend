===== main.py =====
import uvicorn
from fastapi import FastAPI
from services.namecheap_service import NamecheapService
from routes.domain_routes import router as domain_router
from routes.auth_routes import router as auth_router
from routes.user_routes import router as user_router
from routes.auction_routes import router as auction_router
from routes.listing_routes import router as listing_router
from database.connection import engine, Base
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

Base.metadata.create_all(bind=engine)

app.include_router(auth_router, prefix="/auth", tags=["auth"])
app.include_router(domain_router, prefix="/domains", tags=["domains"])
app.include_router(user_router, prefix="/users", tags=["users"])
app.include_router(auction_router, prefix="/auctions", tags=["auctions"])
app.include_router(listing_router, prefix="/listings", tags=["listings"])

@app.get("/")
async def root():
    return {"message": "Hello World"}

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)

===== test.py =====
import os

output_file = "all_code.txt"

with open(output_file, "w", encoding="utf-8") as out:
    for root, dirs, files in os.walk("."):
        # prevent descending into .venv and tests
        if ".venv" in dirs:
            dirs.remove(".venv")
        if "tests" in dirs:
            dirs.remove("tests")

        # sort for consistent output
        dirs.sort()
        files.sort()

        for file in files:
            if file.endswith(".py"):
                filepath = os.path.join(root, file)
                relpath = os.path.relpath(filepath, ".")  # relative path
                out.write(f"===== {relpath} =====\n")
                with open(filepath, "r", encoding="utf-8", errors="ignore") as f:
                    out.write(f.read())
                    out.write("\n\n")

===== database\__init__.py =====


===== database\connection.py =====
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

DATABASE_URL = "postgresql://postgres:1234@localhost/DomainMarkets"

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)
Base = declarative_base()

def get_db():
    from models.db_models import User, UserDetails, Domain
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

Base.metadata.create_all(bind=engine)

===== database\database.py =====
import psycopg2
import psycopg2.extras  # Import extras
from dotenv import load_dotenv
import os

# Load environment variables from .env
load_dotenv()

# Fetch variables
USER = os.getenv("user")
PASSWORD = os.getenv("password")
HOST = os.getenv("host")
PORT = os.getenv("port")
DBNAME = os.getenv("dbname")

# Connect to the database
try:
    connection = psycopg2.connect(
        user=USER,
        password=PASSWORD,
        host=HOST,
        port=PORT,
        dbname=DBNAME
    )
    print("Connection successful!")

    # Create a cursor with DictCursor
    cursor = connection.cursor(cursor_factory=psycopg2.extras.DictCursor)

    # Fetch and print users
    cursor.execute('SELECT * FROM users;')
    for record in cursor.fetchall():
        print(record['name'], record['role'])  # Now this will work!

except Exception as e:
    print(f"Failed to connect: {e}")

finally:
    if connection:
        cursor.close()
        connection.close()


===== models\__init__.py =====


===== models\api_dto.py =====
from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import datetime
from decimal import Decimal



class DomainRegisterUserDetails(BaseModel):
    phone_number: str
    first_name: str
    last_name: str
    address: str
    city: str
    state: str
    zip_code: str
    country: str

class DomainRegistrationRequest(BaseModel):
    domain: str
    years: int = 1

class LoginRequest(BaseModel):
    username: str
    password: str

class RegisterRequest(BaseModel):
    username: str
    email: str
    password: str

class DomainsCheckRequest(BaseModel):
    domain: str

class PaymentRequest(BaseModel):
    domain: str
    price: float
    years: int = 1


class AuctionCreateRequest(BaseModel):
    domain_name: str
    start_price: float = Field(..., gt=0, description="The starting price for the auction.")
    duration_days: int = Field(..., gt=0, le=30, description="The duration of the auction in days.")

class BidCreateRequest(BaseModel):
    amount: float = Field(..., gt=0, description="The amount to bid.")

class BidResponse(BaseModel):
    bidder_username: str
    bid_amount: float
    created_at: datetime

    class Config:
        orm_mode = True

class AuctionResponse(BaseModel):
    id: int
    domain_name: str
    seller_username: str
    start_price: float
    current_highest_bid: Optional[float] = 0.0
    end_time: datetime
    status: str
    bids: List[BidResponse] = []
    winner_username: Optional[str] = None

    class Config:
        orm_mode = True


class ListingCreateRequest(BaseModel):
    domain_name: str
    price: float = Field(..., gt=0, description="The fixed price for the domain.")


class ListingResponse(BaseModel):
    id: int
    domain_name: str
    seller_username: str
    price: float
    created_at: datetime
    sold_at: Optional[datetime] = None
    status: str
    buyer_username: Optional[str] = None

    class Config:
        orm_mode = True


class SavePaymentRequest(BaseModel):
    username: str
    payment_method_id: str

class UserDomainResponse(BaseModel):
    id: int
    domain_name: str
    price: Decimal
    bought_date: datetime
    expiry_date: datetime

    class Config:
        orm_mode = True

class UserTransactionResponse(BaseModel):
    id: int
    transaction_type: str
    amount: Decimal
    currency: str
    transaction_date: datetime
    status: str
    description: Optional[str] = None
    domain_name_at_purchase: Optional[str] = None
    years_purchased: Optional[int] = None

    class Config:
        orm_mode = True

class UserMyDetailsResponse(BaseModel):
    username: str
    email: str

    class Config:
        from_attributes = True

===== models\db_models.py =====
from sqlalchemy import Column, Integer, String, ForeignKey, DateTime, Numeric, Enum
from sqlalchemy.orm import relationship
from database.connection import Base
from datetime import datetime
import enum

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True)
    email = Column(String, nullable=False)
    password_hash = Column(String)
    stripe_customer_id = Column(String, nullable=True)
    stripe_payment_method_id = Column(String, nullable=True)

    # Relationships
    details = relationship("UserDetails", back_populates="user", uselist=False, cascade="all, delete-orphan")
    domains = relationship("Domain", back_populates="user")

class UserDetails(Base):
    __tablename__ = "user_details"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), unique=True)
    email = Column(String, nullable=False)
    phone_number = Column(String, nullable=True)
    first_name = Column(String, nullable=True)
    last_name = Column(String, nullable=True)
    address = Column(String, nullable=True)
    city = Column(String, nullable=True)
    state = Column(String, nullable=True)
    zip_code = Column(String, nullable=True)
    country = Column(String, nullable=True)

    # Relationship with User
    user = relationship("User", back_populates="details")

class Domain(Base):
    __tablename__ = "domains"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    domain_name = Column(String, unique=True, index=True)
    price = Column(Numeric(10, 2), nullable=False)
    bought_date = Column(DateTime, nullable=False, default=datetime.utcnow)
    expiry_date = Column(DateTime, nullable=False)

    # Relationships
    user = relationship("User", back_populates="domains")
    auction = relationship("Auction", back_populates="domain", uselist=False)
    listing = relationship("Listing", back_populates="domain", uselist=False)


class AuctionStatus(enum.Enum):
    PENDING = "PENDING"
    ACTIVE = "ACTIVE"
    CLOSED = "CLOSED"
    CANCELLED = "CANCELLED"


class Auction(Base):
    __tablename__ = "auctions"

    id = Column(Integer, primary_key=True, index=True)
    domain_id = Column(Integer, ForeignKey("domains.id"), unique=True, nullable=False)
    seller_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    winner_id = Column(Integer, ForeignKey("users.id"), nullable=True)

    start_price = Column(Numeric(10, 2), nullable=False)
    start_time = Column(DateTime, default=datetime.utcnow)
    end_time = Column(DateTime, nullable=False)
    status = Column(Enum(AuctionStatus), default=AuctionStatus.ACTIVE)

    domain = relationship("Domain", back_populates="auction")
    seller = relationship("User", foreign_keys='Auction.seller_id')
    winner = relationship("User", foreign_keys='Auction.winner_id')
    bids = relationship("Bid", back_populates="auction", cascade="all, delete-orphan", order_by="desc(Bid.bid_amount)")


class Bid(Base):
    __tablename__ = "bids"

    id = Column(Integer, primary_key=True, index=True)
    auction_id = Column(Integer, ForeignKey("auctions.id"), nullable=False)
    bidder_id = Column(Integer, ForeignKey("users.id"), nullable=False)

    bid_amount = Column(Numeric(10, 2), nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    auction = relationship("Auction", back_populates="bids")
    bidder = relationship("User")


class ListingStatus(enum.Enum):
    ACTIVE = "ACTIVE"
    SOLD = "SOLD"
    CANCELLED = "CANCELLED"


class Listing(Base):
    __tablename__ = "listings"

    id = Column(Integer, primary_key=True, index=True)
    domain_id = Column(Integer, ForeignKey("domains.id"), unique=True, nullable=False)
    seller_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    buyer_id = Column(Integer, ForeignKey("users.id"), nullable=True)

    price = Column(Numeric(10, 2), nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    sold_at = Column(DateTime, nullable=True)
    status = Column(Enum(ListingStatus), default=ListingStatus.ACTIVE)

    domain = relationship("Domain", back_populates="listing")
    seller = relationship("User", foreign_keys='Listing.seller_id')
    buyer = relationship("User", foreign_keys='Listing.buyer_id')


class TransactionType(enum.Enum):
    DOMAIN_REGISTRATION = "DOMAIN_REGISTRATION"
    DOMAIN_RENEWAL = "DOMAIN_RENEWAL"
    DOMAIN_TRANSFER = "DOMAIN_TRANSFER"
    AUCTION_WIN = "AUCTION_WIN"
    AUCTION_SALE = "AUCTION_SALE"
    LISTING_PURCHASE = "LISTING_PURCHASE"
    LISTING_SALE = "LISTING_SALE"


class Transaction(Base):
    __tablename__ = "transactions"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    domain_id = Column(Integer, ForeignKey("domains.id"), nullable=True)
    auction_id = Column(Integer, ForeignKey("auctions.id"), nullable=True)
    listing_id = Column(Integer, ForeignKey("listings.id"), nullable=True)

    transaction_type = Column(Enum(TransactionType), nullable=False)
    amount = Column(Numeric(10, 2), nullable=False)
    currency = Column(String, default="CAD")
    transaction_date = Column(DateTime, default=datetime.utcnow)
    status = Column(String, default="COMPLETED")
    description = Column(String, nullable=True)

    domain_name_at_purchase = Column(String, nullable=True)
    years_purchased = Column(Integer, nullable=True)

    user = relationship("User", backref="transactions")
    domain = relationship("Domain", backref="transactions")
    auction = relationship("Auction", backref="transactions")
    listing = relationship("Listing", backref="transactions")

===== routes\__init__.py =====


===== routes\auction_routes.py =====
from fastapi import APIRouter, Depends, status
from sqlalchemy.orm import Session
from typing import List

from stripe import PaymentMethodService

from database.connection import get_db
from services.auth_service import AuthService
from services.auction_service import AuctionService
from models.api_dto import AuctionCreateRequest, BidCreateRequest, AuctionResponse
from services.payment_service import PaymentService

router = APIRouter()
auth_service = AuthService()
auction_service = AuctionService()
payment_method_service = PaymentService()

@router.post("/", status_code=status.HTTP_201_CREATED, response_model=AuctionResponse)
def create_auction(
    request: AuctionCreateRequest,
    db: Session = Depends(get_db),
    username: str = Depends(auth_service.verify_token)
):
    """
    Create a new auction for a domain owned by the authenticated user.
    """
    auction = auction_service.create_auction(request, username, db)
    return auction_service._format_auction_response(auction)


@router.get("/my-selling-auctions", response_model=List[AuctionResponse])
def get_my_selling_auctions(
    db: Session = Depends(get_db),
    username: str = Depends(auth_service.verify_token)
):
    """
    Get a list of auctions where the authenticated user is the seller.
    """
    return auction_service.get_auctions_by_seller(username, db)

@router.get("/my-bidding-auctions", response_model=List[AuctionResponse])
def get_my_bidding_auctions(
    db: Session = Depends(get_db),
    username: str = Depends(auth_service.verify_token)
):
    """
    Get a list of auctions where the authenticated user has placed a bid.
    """
    return auction_service.get_auctions_by_bidder(username, db)

@router.get("/my-won-auctions", response_model=List[AuctionResponse])
def get_my_won_auctions(
    db: Session = Depends(get_db),
    username: str = Depends(auth_service.verify_token)
):
    """
    Get a list of auctions won by the authenticated user.
    """
    return auction_service.get_auctions_won_by_user(username, db)

@router.get("/", response_model=List[AuctionResponse])
def get_active_auctions(db: Session = Depends(get_db)):
    """
    Get a list of all currently active auctions.
    """
    return auction_service.get_active_auctions(db)


@router.get("/{auction_id}", response_model=AuctionResponse)
def get_auction_details(
    auction_id: int,
    db: Session = Depends(get_db)
):
    """
    Get detailed information about a single auction, including all bids.
    """
    return auction_service.get_auction_details(auction_id, db)


@router.post("/{auction_id}/bids", response_model=AuctionResponse)
def place_bid(
    auction_id: int,
    request: BidCreateRequest,
    db: Session = Depends(get_db),
    username: str = Depends(auth_service.verify_token)
):
    """
    Place a bid on an active auction.
    """
    auction = auction_service.place_bid(auction_id, request, username, db)
    return auction_service._format_auction_response(auction)


@router.post("/{auction_id}/close", response_model=AuctionResponse)
def close_auction(
    auction_id: int,
    db: Session = Depends(get_db),
    username: str = Depends(auth_service.verify_token)
):
    """
    Close an auction. Can only be done by the seller.
    This will determine the winner and transfer the domain.
    """
    return auction_service.close_auction(auction_id, username, db)




===== routes\auth_routes.py =====
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from services.auth_service import AuthService
from services.database_service import DatabaseService
from database.connection import get_db
from models.api_dto import RegisterRequest
from models.api_dto import LoginRequest

router = APIRouter()
auth_service = AuthService()


@router.post("/register")
def register(request: RegisterRequest, db: Session = Depends(get_db)):
    user = auth_service.create_user(request.username, request.email, request.password, db)
    return {"message": "User registered successfully", "user": user.username}


@router.post("/login")
def login(request: LoginRequest, db: Session = Depends(get_db)):
    user = auth_service.authenticate_user(request.username, request.password, db)
    if not user:
        raise HTTPException(status_code=401, detail="Invalid credentials")

    token = auth_service.create_access_token(user.username)
    return {"access_token": token, "token_type": "bearer"}


===== routes\domain_routes.py =====
from fastapi import APIRouter, Query, Depends, HTTPException
from typing import List
from database.connection import get_db
from sqlalchemy.orm import Session
from models.api_dto import PaymentRequest, UserDomainResponse
from services import payment_service
from services.namecheap_service import NamecheapService
from services.auth_service import AuthService
from services.database_service import DatabaseService

router = APIRouter()
namecheap = NamecheapService()
payment = payment_service.PaymentService()
auth_service = AuthService()
database_service = DatabaseService()

@router.get("/check")
def check_domain(domain: str = Query(...), username: str = Depends(auth_service.verify_token)):
    """Check availability of a single domain."""
    if not domain:
        return {"error": "No domain provided"}
    return namecheap.check_domain_availability(domain)

@router.get("/trending-domains")
def trending_domains(username: str = Depends(auth_service.verify_token)):
    """Gets the trending domains"""
    return namecheap.get_trending_available_domains()

@router.get("/trending-tlds")
def get_trending_tlds(username: str = Depends(auth_service.verify_token)):
    """Get trending TLDs."""
    return namecheap.get_trending_tlds()

@router.post("/purchase-domain")
def purchase_domain(
    payment_details: PaymentRequest,
    username: str = Depends(auth_service.verify_token),
    db: Session = Depends(get_db),
):
    return payment.purchase_domain(payment_details, username, db)

# @router.post("/register")
# def register_domain(domain: str = Query(...),years: int = Query(...),
#                     username: str = Depends(auth_service.verify_token), db: Session = Depends(get_db)):
#     """Register a domain using Namecheap for the authenticated user."""
#     return namecheap.register_domain(domain, years, username, db)







===== routes\listing_routes.py =====
from fastapi import APIRouter, Depends, status
from sqlalchemy.orm import Session
from typing import List

from database.connection import get_db
from services.auth_service import AuthService
from services.listing_service import ListingService
from models.api_dto import ListingCreateRequest, ListingResponse

router = APIRouter()
auth_service = AuthService()
listing_service = ListingService()


@router.post("/", status_code=status.HTTP_201_CREATED, response_model=ListingResponse)
def create_listing(
    request: ListingCreateRequest,
    db: Session = Depends(get_db),
    username: str = Depends(auth_service.verify_token)
):
    """
    Create a new fixed-price listing for a domain owned by the authenticated user.
    """
    listing = listing_service.create_listing(request, username, db)
    return listing_service._format_listing_response(listing)


@router.get("/", response_model=List[ListingResponse])
def get_active_listings(db: Session = Depends(get_db)):
    """
    Get a list of all currently active listings.
    """
    return listing_service.get_active_listings(db)


@router.get("/my-listings", response_model=List[ListingResponse])
def get_my_listings(
    db: Session = Depends(get_db),
    username: str = Depends(auth_service.verify_token)
):
    """
    Get a list of all listings created by the authenticated user.
    """
    return listing_service.get_listings_by_seller(username, db)


@router.get("/my-purchases", response_model=List[ListingResponse])
def get_my_purchases(
    db: Session = Depends(get_db),
    username: str = Depends(auth_service.verify_token)
):
    """
    Get a list of all domains purchased by the authenticated user via listings.
    """
    return listing_service.get_listings_purchased_by_user(username, db)


@router.get("/{listing_id}", response_model=ListingResponse)
def get_listing_details(
    listing_id: int,
    db: Session = Depends(get_db)
):
    """
    Get detailed information about a single listing.
    """
    return listing_service.get_listing_details(listing_id, db)


@router.post("/{listing_id}/purchase", response_model=ListingResponse)
def purchase_listing(
    listing_id: int,
    db: Session = Depends(get_db),
    username: str = Depends(auth_service.verify_token)
):
    """
    Purchase a domain from an active listing.
    """
    return listing_service.purchase_listing(listing_id, username, db)


@router.delete("/{listing_id}", response_model=ListingResponse)
def cancel_listing(
    listing_id: int,
    db: Session = Depends(get_db),
    username: str = Depends(auth_service.verify_token)
):
    """
    Cancel an active listing. Can only be done by the seller.
    """
    return listing_service.cancel_listing(listing_id, username, db)

===== routes\user_routes.py =====
from fastapi import APIRouter, Depends

from services.namecheap_service import NamecheapService
from services.payment_service import PaymentService
from services.auth_service import AuthService
from services.database_service import DatabaseService

from models.api_dto import DomainRegisterUserDetails, UserDomainResponse, UserTransactionResponse, SavePaymentRequest, \
    UserMyDetailsResponse
from database.connection import get_db
from sqlalchemy.orm import Session
from typing import List

router = APIRouter()
namecheap = NamecheapService()
database_service = DatabaseService()
auth_service = AuthService()
payment_service = PaymentService()


@router.get("/user-details")
def get_user_details(username: str = Depends(auth_service.verify_token), db: Session = Depends(get_db)):
    """Check availability of additional details in user_details model."""
    details = database_service.get_user_details(username, db)
    return details

@router.post("/user-details")
def post_user_details(user_details: DomainRegisterUserDetails, username: str = Depends(auth_service.verify_token),
        db: Session = Depends(get_db)):
    """Save or update additional user details."""
    saved_details = database_service.create_or_update_user_details(username, user_details, db)
    return {"message": "User details saved successfully", "details": saved_details}

@router.get("/my-domains", response_model=List[UserDomainResponse])
def get_my_domains(username: str = Depends(auth_service.verify_token), db: Session = Depends(get_db)):
    """
    Get a list of all domains owned by the user.
    """
    domains = database_service.get_user_domains(username, db)
    return domains

@router.get("/my-transactions", response_model=List[UserTransactionResponse])
def get_my_transactions(username: str = Depends(auth_service.verify_token), db: Session = Depends(get_db)):
    """
    Get a list of all transactions owned by the user.
    """
    transactions = database_service.get_user_transactions(username, db)
    return transactions

@router.get("/", response_model=UserMyDetailsResponse)
def get_user(username: str = Depends(auth_service.verify_token), db: Session = Depends(get_db)):
    """Gets the current user's details"""
    user = database_service.get_user(username, db)
    return user


@router.post("/setup-intent")
def setup_intent(
        username: str = Depends(auth_service.verify_token),
        db: Session = Depends(get_db)
):
    """Creates a setup intent for the authenticated user to save a payment method."""
    return payment_service.create_setup_intent(username, db)

@router.post("/save-payment-method")
def save_payment_method(
    request: SavePaymentRequest,
    username: str = Depends(auth_service.verify_token),
    db: Session = Depends(get_db)
):
    """Saves a payment method for the authenticated user."""
    return payment_service.save_payment_method(username, request.payment_method_id, db)

@router.get("/payment-info/")
def get_payment_info(
    username: str = Depends(auth_service.verify_token),
    db: Session = Depends(get_db)
):
    """Gets payment information for the authenticated user."""
    return payment_service.get_payment_info(username, db)

@router.delete("/payment-method/")
def remove_payment_method(
    username: str = Depends(auth_service.verify_token),
    db: Session = Depends(get_db)
):
    """Removes the payment method for the authenticated user."""
    return payment_service.remove_payment_method(username, db)

===== services\__init__.py =====


===== services\auction_service.py =====
import stripe
from fastapi import HTTPException, status
from sqlalchemy.orm import Session
from datetime import datetime, timedelta
from models.db_models import User, Domain, Auction, Bid, AuctionStatus, TransactionType
from models.api_dto import AuctionCreateRequest, BidCreateRequest, AuctionResponse, BidResponse
from typing import List

from services.payment_service import PaymentService


class AuctionService:
    def create_auction(self, request: AuctionCreateRequest, username: str, db: Session):
        # Find the user who is creating the auction
        seller = db.query(User).filter(User.username == username).first()
        if not seller:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Seller not found.")

        # Find the domain and verify ownership
        domain = db.query(Domain).filter(Domain.domain_name == request.domain_name).first()
        if not domain:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Domain not found.")

        if domain.user_id != seller.id:
            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="You do not own this domain.")

        # Check if the domain is already in an auction
        existing_auction = db.query(Auction).filter(Auction.domain_id == domain.id,
                                                    Auction.status == AuctionStatus.ACTIVE).first()
        if existing_auction:
            raise HTTPException(status_code=status.HTTP_409_CONFLICT,
                                detail="This domain is already in an active auction.")

        # Create the new auction
        end_time = datetime.utcnow() + timedelta(days=request.duration_days)
        new_auction = Auction(
            domain_id=domain.id,
            seller_id=seller.id,
            start_price=request.start_price,
            end_time=end_time,
            status=AuctionStatus.ACTIVE
        )
        db.add(new_auction)
        db.commit()
        db.refresh(new_auction)
        return new_auction

    def place_bid(self, auction_id: int, request: BidCreateRequest, username: str, db: Session):
        # 1. Find the bidder and the auction
        bidder = db.query(User).filter(User.username == username).first()
        auction = db.query(Auction).get(auction_id)

        if not bidder.stripe_payment_method_id:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Setup payment method not found.")

        if not auction:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Auction not found.")

        # 2. Validation checks
        if auction.status != AuctionStatus.ACTIVE:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="This auction is not active.")

        if auction.end_time < datetime.utcnow():
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="This auction has already ended.")

        if auction.seller_id == bidder.id:
            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="You cannot bid on your own auction.")

        # 3. Check if bid amount is valid
        highest_bid = db.query(Bid).filter(Bid.auction_id == auction_id).order_by(Bid.bid_amount.desc()).first()

        min_bid_amount = highest_bid.bid_amount if highest_bid else auction.start_price

        if request.amount <= min_bid_amount:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST,
                                detail=f"Your bid must be higher than the current highest bid of ${min_bid_amount}.")

        # 4. Create and save the new bid
        new_bid = Bid(
            auction_id=auction.id,
            bidder_id=bidder.id,
            bid_amount=request.amount
        )
        db.add(new_bid)
        db.commit()
        db.refresh(auction)  # Refresh auction to show new bid
        return auction

    def get_auction_details(self, auction_id: int, db: Session):
        auction = db.query(Auction).get(auction_id)
        if not auction:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Auction not found.")
        return self._format_auction_response(auction)

    def get_active_auctions(self, db: Session):
        auctions = db.query(Auction).filter(Auction.status == AuctionStatus.ACTIVE).all()
        return [self._format_auction_response(auc) for auc in auctions]

    def close_auction(self, auction_id: int, username: str, db: Session):
        # 1. Find the auction and the user trying to close it
        auction = db.query(Auction).get(auction_id)
        user = db.query(User).filter(User.username == username).first()

        if not auction:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Auction not found.")

        # 2. Only the seller can close the auction
        if auction.seller_id != user.id:
            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Only the seller can close this auction.")

        if auction.status != AuctionStatus.ACTIVE:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Auction is not active.")

        # 3. Find the winning bid
        winning_bid = (
            db.query(Bid)
            .filter(Bid.auction_id == auction_id)
            .order_by(Bid.bid_amount.desc())
            .first()
        )

        if winning_bid:
            # A winner exists, so we process the transfer and transactions
            auction.winner_id = winning_bid.bidder_id

            # --- A. Transfer domain ownership and update its details ---
            domain = db.query(Domain).get(auction.domain_id)
            domain.user_id = winning_bid.bidder_id
            domain.bought_date = datetime.utcnow()
            domain.price = winning_bid.bid_amount

            # --- B. Process payment with Stripe ---
            winner = db.query(User).get(winning_bid.bidder_id)
            if not winner.stripe_customer_id or not winner.stripe_payment_method_id:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Winner does not have a saved payment method."
                )

            try:
                payment_intent = stripe.PaymentIntent.create(
                    amount=int(winning_bid.bid_amount * 100),  # Stripe expects cents
                    currency="cad",
                    customer=winner.stripe_customer_id,
                    payment_method=winner.stripe_payment_method_id,
                    off_session=True,  # no user interaction at auction close
                    confirm=True
                )
                payment_status = payment_intent.status  # succeeded, requires_action, etc.
            except stripe.error.CardError as e:
                # Card declined, insufficient funds, etc.
                raise HTTPException(
                    status_code=status.HTTP_402_PAYMENT_REQUIRED,
                    detail=f"Payment failed: {e.user_message}"
                )

            payment_service = PaymentService()

            # Transaction for the WINNER (Buyer)
            payment_service.create_transaction(
                user_id=winning_bid.bidder_id,
                domain_id=domain.id,
                auction_id=auction.id,
                transaction_type=TransactionType.AUCTION_WIN,
                amount=winning_bid.bid_amount,
                description=f"Won auction for domain {domain.domain_name}",
                domain_name_at_purchase=domain.domain_name,
                status=payment_status.upper(),
                db=db
            )

            # Transaction for the SELLER
            payment_service.create_transaction(
                user_id=auction.seller_id,
                domain_id=domain.id,
                auction_id=auction.id,
                transaction_type=TransactionType.AUCTION_SALE,
                amount=winning_bid.bid_amount,
                description=f"Sold domain {domain.domain_name} in auction",
                domain_name_at_purchase=domain.domain_name,
                status=payment_status.upper(),
                db=db
            )

        # 4. Mark the auction as closed
        auction.status = AuctionStatus.CLOSED

        # 5. Commit all changes to the database at once
        db.commit()
        db.refresh(auction)

        return self._format_auction_response(auction)

    def _format_auction_response(self, auction: Auction):
        """Helper to format the response model consistently."""
        highest_bid = auction.bids[0].bid_amount if auction.bids else None

        return AuctionResponse(
            id=auction.id,
            domain_name=auction.domain.domain_name,
            seller_username=auction.seller.username,
            start_price=float(auction.start_price),
            current_highest_bid=float(highest_bid) if highest_bid else None,
            end_time=auction.end_time,
            status=auction.status.value,
            winner_username=auction.winner.username if auction.winner else None,
            bids=[BidResponse(
                bidder_username=bid.bidder.username,
                bid_amount=float(bid.bid_amount),
                created_at=bid.created_at
            ) for bid in auction.bids]
        )

    def get_auctions_by_seller(self, username: str, db: Session) -> List[AuctionResponse]:
        seller = db.query(User).filter(User.username == username).first()
        if not seller:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Seller user not found.")

        auctions = db.query(Auction).filter(
            Auction.seller_id == seller.id
        ).all()
        return [self._format_auction_response(auc) for auc in auctions]

    def get_auctions_by_bidder(self, username: str, db: Session) -> List[AuctionResponse]:
        bidder_user = db.query(User).filter(User.username == username).first()
        if not bidder_user:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Bidder user not found.")

        # Get auction IDs where this user has placed a bid
        bidded_auction_ids = db.query(Bid.auction_id).filter(Bid.bidder_id == bidder_user.id).distinct().all()
        bidded_auction_ids = [aid[0] for aid in bidded_auction_ids] # Extract IDs from tuples

        auctions = db.query(Auction).filter(
            Auction.id.in_(bidded_auction_ids)
        ).all()
        return [self._format_auction_response(auc) for auc in auctions]

    def get_auctions_won_by_user(self, username: str, db: Session) -> List[AuctionResponse]:
        winner_user = db.query(User).filter(User.username == username).first()
        if not winner_user:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Winner user not found.")

        auctions = db.query(Auction).filter(
            Auction.winner_id == winner_user.id,
            Auction.status == AuctionStatus.CLOSED
        ).all()
        return [self._format_auction_response(auc) for auc in auctions]

===== services\auth_service.py =====
from datetime import datetime, timedelta
import jwt
from fastapi.security import OAuth2PasswordBearer
from passlib.context import CryptContext
from sqlalchemy.orm import Session
from models.db_models import User, UserDetails
from fastapi import HTTPException, Depends
from dotenv import load_dotenv
import os
import logging

logger = logging.getLogger(__name__)

load_dotenv()

SECRET_KEY = os.getenv("SECRET_KEY")
ALGORITHM = "HS256"
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


class AuthService:
    def create_user(self, username: str, email: str, password: str, db: Session):
        hashed_password = pwd_context.hash(password)
        user = User(username=username, email=email, password_hash=hashed_password)
        db.add(user)
        db.commit()
        db.refresh(user)

        user_details = UserDetails(user_id=user.id, email=email)
        db.add(user_details)
        db.commit()
        return user

    def authenticate_user(self, username: str, password: str, db: Session):
        user = db.query(User).filter(User.username == username).first()
        if user and pwd_context.verify(password, user.password_hash):
            return user
        return None

    def create_access_token(self, username: str):
        expiration = datetime.utcnow() + timedelta(hours=1000)
        token_data = {"sub": username, "exp": expiration}
        return jwt.encode(token_data, SECRET_KEY, algorithm=ALGORITHM)

    def verify_token(self, token: str = Depends(oauth2_scheme)):
        """Verify the JWT token and return the username."""
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            return payload.get("sub")  # Extract the username
        except jwt.ExpiredSignatureError:
            logger.warning(f"Authentication failed: Token expired")
            raise HTTPException(status_code=401, detail="Token expired")
        except jwt.InvalidTokenError:
            logger.warning(f"Authentication failed: Invalid token")
            raise HTTPException(status_code=401, detail="Invalid token")

===== services\database_service.py =====
from fastapi import HTTPException
from sqlalchemy.orm import Session, joinedload

from database.connection import get_db
from models.db_models import User, UserDetails, Domain, Auction, Transaction
from models.api_dto import DomainRegisterUserDetails

class DatabaseService:
    def get_user_domains(self, username: str, db: Session):
        """Fetch all domains owned by a user."""
        user = db.query(User).filter(User.username == username).first()
        if not user:
            return []  # Or raise HTTPException if user not found

        domains = db.query(Domain).filter(Domain.user_id == user.id).all()
        return domains

    def get_user_auctions(self, username: str, db: Session):
        """Fetch all domains owned by a user."""
        user = db.query(User).filter(User.username == username).first()
        if not user:
            return []  # Or raise HTTPException if user not found

        auctions = db.query(Auction).filter(Auction.seller_id == user.id).all()
        return auctions

    def get_user_transactions(self, username: str, db: Session):
        user = db.query(User).filter(User.username == username).first()
        if not user:
            return []
        transactions = db.query(Transaction).filter(Transaction.user_id == user.id).order_by(Transaction.transaction_date.desc()).all()
        return transactions

    def get_user_details(self, username: str, db):
        """Fetch user details based on the username."""
        user = db.query(User).filter(User.username == username).one()
        user_details = db.query(UserDetails).filter(UserDetails.user_id == user.id).one()
        return user_details

    def get_user(self, username: str, db: Session):
        """
        Fetches a user and their email from the related details table efficiently.
        """
        user = db.query(User).filter(User.username == username).one_or_none()

        if not user:
            raise HTTPException(status_code=404, detail="User not found")
        return {
            "username": user.username,
            "email": user.email
        }


    def create_or_update_user_details(self, username: str, user_details_dto: DomainRegisterUserDetails, db):
        """Create or update user details for a given username."""
        user = db.query(User).filter(User.username == username).one()
        user_details = db.query(UserDetails).filter(UserDetails.user_id == user.id).first()

        if not user_details:
            user_details = UserDetails(user_id=user.id)

        formatted_phone = self._format_phone_number(user_details_dto.phone_number)
        user_details.phone_number = formatted_phone
        user_details.first_name = user_details_dto.first_name
        user_details.last_name = user_details_dto.last_name
        user_details.address = user_details_dto.address
        user_details.city = user_details_dto.city
        user_details.state = user_details_dto.state
        user_details.zip_code = user_details_dto.zip_code
        user_details.country = user_details_dto.country

        db.add(user_details)
        db.commit()
        db.refresh(user_details)
        return user_details

    def _format_phone_number(self, phone_number: str) -> str:
        """Format phone number to +NNN.NNNNNNNNNN format."""
        if not phone_number:
            return phone_number

        digits_only = ''.join(filter(str.isdigit, phone_number))

        if len(digits_only) < 10:
            return phone_number

        last_10 = digits_only[-10:]
        country_code = digits_only[:-10]

        if not country_code:
            country_code = "1"
        return f"+{country_code}.{last_10}"

if __name__ == "__main__":
    database_service = DatabaseService()
    db = next(get_db())
    details = database_service.get_user_details(username="omkar", db=db)
    print(details.email)
    print(details.first_name)




===== services\listing_service.py =====
import stripe
from fastapi import HTTPException, status
from sqlalchemy.orm import Session
from datetime import datetime
from models.db_models import User, Domain, Listing, ListingStatus, Auction, AuctionStatus, TransactionType
from models.api_dto import ListingCreateRequest, ListingResponse
from typing import List

from services.payment_service import PaymentService


class ListingService:
    def create_listing(self, request: ListingCreateRequest, username: str, db: Session):
        """Create a new fixed-price listing for a domain owned by the authenticated user."""
        # Find the user who is creating the listing
        seller = db.query(User).filter(User.username == username).first()
        if not seller:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Seller not found.")

        # Find the domain and verify ownership
        domain = db.query(Domain).filter(Domain.domain_name == request.domain_name).first()
        if not domain:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Domain not found.")

        if domain.user_id != seller.id:
            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="You do not own this domain.")

        # Check if the domain is already in an active auction
        existing_auction = db.query(Auction).filter(
            Auction.domain_id == domain.id,
            Auction.status == AuctionStatus.ACTIVE
        ).first()
        if existing_auction:
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail="This domain is already in an active auction."
            )

        # Check if the domain is already listed
        existing_listing = db.query(Listing).filter(
            Listing.domain_id == domain.id,
            Listing.status == ListingStatus.ACTIVE
        ).first()
        if existing_listing:
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail="This domain is already listed for sale."
            )

        # Create the new listing
        new_listing = Listing(
            domain_id=domain.id,
            seller_id=seller.id,
            price=request.price,
            status=ListingStatus.ACTIVE
        )
        db.add(new_listing)
        db.commit()
        db.refresh(new_listing)
        return new_listing

    def get_active_listings(self, db: Session):
        """Get all active listings."""
        listings = db.query(Listing).filter(Listing.status == ListingStatus.ACTIVE).all()
        return [self._format_listing_response(listing) for listing in listings]

    def get_listing_details(self, listing_id: int, db: Session):
        """Get detailed information about a single listing."""
        listing = db.query(Listing).get(listing_id)
        if not listing:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Listing not found.")
        return self._format_listing_response(listing)

    def get_listings_by_seller(self, username: str, db: Session) -> List[ListingResponse]:
        """Get all listings created by a specific seller."""
        seller = db.query(User).filter(User.username == username).first()
        if not seller:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Seller not found.")

        listings = db.query(Listing).filter(Listing.seller_id == seller.id).all()
        return [self._format_listing_response(listing) for listing in listings]

    def get_listings_purchased_by_user(self, username: str, db: Session) -> List[ListingResponse]:
        """Get all listings purchased by a specific user."""
        buyer = db.query(User).filter(User.username == username).first()
        if not buyer:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Buyer not found.")

        listings = db.query(Listing).filter(
            Listing.buyer_id == buyer.id,
            Listing.status == ListingStatus.SOLD
        ).all()
        return [self._format_listing_response(listing) for listing in listings]

    def purchase_listing(self, listing_id: int, username: str, db: Session):
        """Purchase a domain from an active listing."""
        # Find the listing and buyer
        listing = db.query(Listing).get(listing_id)
        buyer = db.query(User).filter(User.username == username).first()

        if not listing:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Listing not found.")

        if not buyer:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Buyer not found.")

        # Validation checks
        if listing.status != ListingStatus.ACTIVE:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="This listing is not active.")

        if listing.seller_id == buyer.id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You cannot purchase your own listing."
            )

        # Check if buyer has a saved payment method
        if not buyer.stripe_customer_id or not buyer.stripe_payment_method_id:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="A card is required to complete this purchase. Please add one to your account first."
            )

        # Process payment with Stripe
        try:
            payment_intent = stripe.PaymentIntent.create(
                amount=int(listing.price * 100),  # Stripe expects cents
                currency="cad",
                customer=buyer.stripe_customer_id,
                payment_method=buyer.stripe_payment_method_id,
                off_session=True,
                confirm=True
            )
            payment_status = payment_intent.status
        except stripe.error.CardError as e:
            raise HTTPException(
                status_code=status.HTTP_402_PAYMENT_REQUIRED,
                detail=f"Payment failed: {e.user_message}"
            )

        # Transfer domain ownership
        domain = db.query(Domain).get(listing.domain_id)
        domain.user_id = buyer.id
        domain.bought_date = datetime.utcnow()
        domain.price = listing.price

        # Update listing
        listing.buyer_id = buyer.id
        listing.sold_at = datetime.utcnow()
        listing.status = ListingStatus.SOLD

        payment_service = PaymentService()

        # Create transaction for BUYER
        payment_service.create_transaction(
            user_id=buyer.id,
            domain_id=domain.id,
            listing_id=listing.id,
            transaction_type=TransactionType.LISTING_PURCHASE,
            amount=listing.price,
            description=f"Purchased domain {domain.domain_name} from listing",
            domain_name_at_purchase=domain.domain_name,
            status=payment_status.upper(),
            db=db
        )

        # Create transaction for SELLER
        payment_service.create_transaction(
            user_id=listing.seller_id,
            domain_id=domain.id,
            listing_id=listing.id,
            transaction_type=TransactionType.LISTING_SALE,
            amount=listing.price,
            description=f"Sold domain {domain.domain_name} via listing",
            domain_name_at_purchase=domain.domain_name,
            status=payment_status.upper(),
            db=db
        )

        # Commit all changes
        db.commit()
        db.refresh(listing)

        return self._format_listing_response(listing)

    def cancel_listing(self, listing_id: int, username: str, db: Session):
        """Cancel an active listing. Can only be done by the seller."""
        listing = db.query(Listing).get(listing_id)
        user = db.query(User).filter(User.username == username).first()

        if not listing:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Listing not found.")

        # Only the seller can cancel the listing
        if listing.seller_id != user.id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Only the seller can cancel this listing."
            )

        if listing.status != ListingStatus.ACTIVE:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Listing is not active."
            )

        # Cancel the listing
        listing.status = ListingStatus.CANCELLED
        db.commit()
        db.refresh(listing)

        return self._format_listing_response(listing)

    def _format_listing_response(self, listing: Listing):
        """Helper to format the response model consistently."""
        return ListingResponse(
            id=listing.id,
            domain_name=listing.domain.domain_name,
            seller_username=listing.seller.username,
            price=float(listing.price),
            created_at=listing.created_at,
            sold_at=listing.sold_at,
            status=listing.status.value,
            buyer_username=listing.buyer.username if listing.buyer else None
        )

===== services\namecheap_service.py =====
import os
import requests
import xml.etree.ElementTree as ET
from dotenv import load_dotenv
import concurrent.futures
from datetime import datetime, timedelta
from services.database_service import DatabaseService
import utils.utils as utils
import models.db_models as models
database_service = DatabaseService()


class NamecheapService:
    def __init__(self):
        load_dotenv()

        self.api_user = os.getenv("API_USER")
        self.api_key = os.getenv("API_KEY")
        self.username = os.getenv("NAMEOFUSER")
        self.client_ip = os.getenv("CLIENT_IP")
        self.api_url = "https://api.sandbox.namecheap.com/xml.response"
        self.tld_price_cache = {}  # Cache for TLD prices

    def _build_api_url(self, command, **params):
        """Builds a Namecheap API request URL with common parameters."""
        base_url = (f"{self.api_url}?ApiUser={self.api_user}&ApiKey={self.api_key}"
                    f"&UserName={self.username}&ClientIp={self.client_ip}&Command={command}")
        for key, value in params.items():
            base_url += f"&{key}={value}"
        return base_url

    def _make_api_request(self, url):
        """Make request to Namecheap API."""
        response = requests.get(url)

        if response.status_code != 200:
            raise Exception(f"Failed to fetch response from Namecheap API. Status code: {response.status_code}")

        return response

    def check_domain_availability(self, domain: str):
        if "." in domain:
            base_name = domain.split('.')[0]
            original_domain = domain
        else:
            base_name = domain
            original_domain = f"{domain}.com"

        similar_domains = utils.generate_similar_domains(base_name)
        all_domains_to_check = [original_domain] + similar_domains

        batch_size = 5
        domain_results = {}
        tlds_to_check = set()

        with concurrent.futures.ThreadPoolExecutor() as executor:
            # Split domains into batches
            batches = [all_domains_to_check[i:i + batch_size]
                       for i in range(0, len(all_domains_to_check), batch_size)]
            future_to_batch = {executor.submit(self._check_domain_batch, batch): batch
                               for batch in batches}

            for future in concurrent.futures.as_completed(future_to_batch):
                batch_results = future.result()
                domain_results.update(batch_results)

                for domain_name in batch_results:
                    tld = domain_name.split(".")[-1]
                    tlds_to_check.add(tld)

        tlds_needing_price = [tld for tld in tlds_to_check if tld not in self.tld_price_cache]
        if tlds_needing_price:
            with concurrent.futures.ThreadPoolExecutor() as executor:
                future_to_tld = {executor.submit(self.get_tld_price, tld): tld
                                 for tld in tlds_needing_price}

                for future in concurrent.futures.as_completed(future_to_tld):
                    tld = future_to_tld[future]
                    try:
                        result = future.result()
                        if not isinstance(result, dict) or "error" not in result:  # If not an error dict
                            # Assuming get_tld_price now returns a dict with price and duration
                            self.tld_price_cache[tld] = result
                    except Exception as e:
                        print(f"Error fetching price for TLD {tld}: {e}")

        for domain_name, domain_data in domain_results.items():
            if not domain_data["is_premium"]:
                tld = domain_name.split(".")[-1]
                if tld in self.tld_price_cache:
                    price_info = self.tld_price_cache[tld]
                    if isinstance(price_info, dict):
                        # If price cache now stores a dict with price and duration
                        domain_data["price"] = price_info["price"]
                        domain_data["min_duration"] = price_info["min_duration"]
                    else:
                        # Backward compatibility if price cache still has just the price
                        domain_data["price"] = price_info
                        domain_data["min_duration"] = 1  # Default duration

        original_result = None
        suggestions = []

        for domain_name, domain_data in domain_results.items():
            if domain_data["available"]:
                domain_info = {
                    "domain": domain_name,
                    "price": domain_data.get("price"),
                    "min_duration": domain_data.get("min_duration", 1)  # Default to 1 if not found
                }

                if domain_name.lower() == original_domain.lower():
                    original_result = domain_info
                else:
                    suggestions.append(domain_info)

        response = {"suggestions": suggestions}
        if original_result:
            response["domain"] = original_result

        return response

    def _check_domain_batch(self, domain_batch):
        """Check availability for a batch of domains, including premium details."""
        url = self._build_api_url("namecheap.domains.check", DomainList=",".join(domain_batch))

        try:
            response = self._make_api_request(url)
            print(response.text)  # Debugging line, can be removed
            root = ET.fromstring(response.text)
            namespace = {"nc": "http://api.namecheap.com/xml.response"}

            batch_results = {}
            for domain_result in root.findall(".//nc:DomainCheckResult", namespace):
                domain_name = domain_result.get("Domain")
                available = domain_result.get("Available") == "true"
                is_premium = domain_result.get("IsPremiumName") == "true"

                if is_premium:
                    premium_price = float(domain_result.get("PremiumRegistrationPrice", 0))
                else:
                    premium_price = 0

                batch_results[domain_name] = {
                    "available": available,
                    "is_premium": is_premium,
                    "price": premium_price
                }

            return batch_results
        except Exception as e:
            print(f"Error checking domain batch: {e}")
            return {}

    def get_trending_tlds(self):
        """Fetches trending TLDs and their pricing."""
        tlds = ["ai", "com", "xyz", "io", "app", "dev", "store", "shop", "online", "co"]
        return tlds

    def get_trending_keywords(self):
        """
        Returns a list of trending keywords for domain names. This list can later be enhanced by fetching from external source
        """
        trending_keywords = [
            "ai", "crypto", "blockchain", "startup", "web3", "nft", "quantum", "cybersecurity", "greenery",
            "automation"
        ]
        return trending_keywords

    def get_trending_available_domains(self):
        """
        Finds trending available domains by checking domain availability for trending keywords.
        """
        trending_keywords = self.get_trending_keywords()
        available_domains = []
        for keyword in trending_keywords:
            domain_name = f"{keyword}.com"
            url_availability = self._build_api_url("namecheap.domains.check", DomainList=domain_name)
            response_availability = self._make_api_request(url_availability)
            print(response_availability.text)
            if response_availability.status_code == 200 and "Available" in response_availability.text:
                domain_price = self.get_tld_price("com")
                available_domains.append({"domain": domain_name, "price": domain_price})

        return available_domains

    def register_domain(self, domain: str, years: int, price, username, db):
        """
        Registers a domain using Namecheap API with only Registrant info.
        """
        user_details = database_service.get_user_details(username, db)
        params = {}
        for contact_type in ['Admin', 'Tech', 'AuxBilling', 'Registrant']:
            params[f'{contact_type}FirstName'] = user_details.first_name
            params[f'{contact_type}LastName'] = user_details.last_name
            params[f'{contact_type}Address1'] = user_details.address
            params[f'{contact_type}City'] = user_details.city
            params[f'{contact_type}StateProvince'] = user_details.state
            params[f'{contact_type}PostalCode'] = user_details.zip_code
            params[f'{contact_type}Country'] = user_details.country
            params[f'{contact_type}Phone'] = user_details.phone_number
            params[f'{contact_type}EmailAddress'] = user_details.email

        params["AddFreeWhoisguard"] = "yes"
        params["WGEnabled"] = "yes"
        params["DomainName"] = domain
        params["Years"] = years

        url = self._build_api_url("namecheap.domains.create", **params)
        try:
            response = self._make_api_request(url)
            root = ET.fromstring(response.text)
            ns = {'ns': 'http://api.namecheap.com/xml.response'}

            # Check for API errors
            error = root.find(".//ns:Error", ns)
            if error is not None:
                return {"success": False, "error": error.text}

            # Check registration result
            result = root.find(".//ns:DomainCreateResult", ns)
            if result is not None and result.attrib.get("Registered") == "true":

                user = db.query(models.User).filter(models.User.username == username).first()
                if user:
                    # Create a new Domain record
                    current_time = datetime.utcnow()
                    expiration_date = current_time + timedelta(days=years * 365)
                    new_domain_record = models.Domain(
                        user_id=user.id,
                        domain_name=domain,
                        price=price,
                        bought_date=current_time,
                        expiry_date=expiration_date
                    )
                    db.add(new_domain_record)
                    db.commit()

                return {
                    "success": True,
                    "message": "Domain registered successfully",
                    "order_id": result.attrib.get("OrderID")
                }

            return {"success": False, "error": "Domain registration failed."}

        except Exception as e:
            return {"success": False, "error": str(e)}

    def get_tld_price(self, tld):
        """Fetches the registration price and minimum duration of a given TLD"""
        # Return cached info if available
        if tld in self.tld_price_cache:
            return self.tld_price_cache[tld]

        url = self._build_api_url(
            "namecheap.users.getPricing",
            ProductType="DOMAIN",
            ProductCategory="REGISTER",
            ProductName=tld.upper()
        )

        try:
            response = self._make_api_request(url)
            ns = {'ns': 'http://api.namecheap.com/xml.response'}  # Namespace dictionary
            root = ET.fromstring(response.text)

            product_element = root.find(
                ".//ns:ProductCategory[@Name='register']/ns:Product[@Name='{0}']".format(tld.lower()),
                namespaces=ns)

            if product_element is not None:
                # Find the price element with the minimum duration
                price_elements = product_element.findall("ns:Price", namespaces=ns)
                if price_elements:
                    # Sort by Duration to find the minimum available
                    price_elements.sort(key=lambda x: int(x.get("Duration", "0")))
                    price_element = price_elements[0]  # Get the one with the lowest duration

                    price_str = price_element.get("Price")
                    duration_str = price_element.get("Duration")

                    if price_str is not None and duration_str is not None:
                        try:
                            price = float(price_str)
                            duration = int(duration_str)
                            converted_price = utils.convert_usd_to_cad(price)

                            # Store both price and duration in the cache
                            result = {
                                "price": converted_price,
                                "min_duration": duration,
                                "duration_type": price_element.get("DurationType", "YEAR")
                            }

                            self.tld_price_cache[tld] = result  # Cache the result
                            return result
                        except ValueError:
                            return {"error": f"Invalid format for price or duration: {price_str}, {duration_str}"}
                    return {"error": f"Price or duration attribute missing for {tld}"}
                else:
                    return {"error": f"No price elements found for {tld}"}
            else:
                return {"error": f"Product not found for {tld}"}

        except ET.ParseError as e:
            return {"error": f"Failed to parse XML response: {str(e)}"}
        except Exception as e:
            return {"error": str(e)}


if __name__ == "__main__":
    domain_checker = NamecheapService()
    #print(domain_checker.get_tld_price("ai"))
    #print(domain_checker.check_domain_availability("omkar.com"))
    print(domain_checker.get_trending_available_domains())
    # print("Fetching trending TLDs...")
    # print(domain_checker.get_trending_tlds())
    #
    # print("Registering a test domain...")
    # print(domain_checker.register_domain("exampletestdomain123.com"))

===== services\payment_service.py =====
import os
import dotenv
from fastapi import HTTPException
from sqlalchemy.orm import Session
import stripe
from stripe import SetupIntent, PaymentMethod

from services.namecheap_service import NamecheapService
from models.db_models import Transaction, TransactionType, Domain, User
from models.api_dto import PaymentRequest


class PaymentService:
    def __init__(self):
        dotenv.load_dotenv()
        stripe.api_key = os.getenv('STRIPE_SECRET_KEY')
        self.namecheap = NamecheapService()

    def purchase_domain(self, payment_details: PaymentRequest, username: str, db: Session):
        """
        Pay for a domain using a saved payment method and register it if payment succeeds.
        """
        # Step 1: Get the user and their saved payment details
        user = db.query(User).filter(User.username == username).first()
        if not user or not user.stripe_customer_id or not user.stripe_payment_method_id:
            raise HTTPException(
                status_code=400,
                detail="A card is required to complete this purchase. Please add one to your account first."
            )

        total_price = payment_details.price
        if total_price <= 0:
            return {"error": "Invalid domain price provided."}

        amount_in_cents = int(total_price * 100)
        domain = payment_details.domain
        years = payment_details.years

        # Step 3: Create and confirm the payment using the saved method
        payment_response = self.create_and_confirm_payment(
            amount=amount_in_cents,
            customer_id=user.stripe_customer_id,
            payment_method_id=user.stripe_payment_method_id
        )
        payment_intent_id = payment_response.get("payment_intent_id")

        if "error" in payment_response:
            return {"error": f"Payment failed: {payment_response['error']}"}

        if payment_response.get("status") != "succeeded":
            return {"error": f"Payment not successful. Status: {payment_response.get('status')}"}

        # Step 4: If payment is successful, register the domain
        registration_result = self.namecheap.register_domain(domain, years, total_price, username, db)
        print(registration_result)

        # Step 5: Registration unsuccessful
        if not registration_result.get("success"):
            self._issue_refund(payment_intent_id)

            raise HTTPException(
                status_code=502,
                detail={
                    "code": "DOMAIN_REGISTRATION_FAILED",
                    "message": "Your payment was successful, but the domain registration failed. Your payment has been automatically refunded.",
                    "provider_error": registration_result.get("error", "Unknown error from domain provider.")
                }
            )

        # Step 6: Create a transaction record
        if registration_result.get("success"):
            registered_domain_obj = db.query(Domain).filter(Domain.domain_name == domain,
                                                            Domain.user_id == user.id).first()
            if registered_domain_obj:
                self.create_transaction(
                    user_id=user.id,
                    domain_id=registered_domain_obj.id,
                    transaction_type=TransactionType.DOMAIN_REGISTRATION,
                    amount=total_price,
                    description=f"Registration of domain {domain} for {years} years.",
                    domain_name_at_purchase=domain,
                    years_purchased=years,
                    status="COMPLETED",
                    db=db
                )

        return {
            "payment_status": payment_response.get("status"),
            "registration_result": registration_result
        }

    def create_and_confirm_payment(self, amount: int, customer_id: str, payment_method_id: str, currency: str = "cad"):
        """
        Creates and confirms a payment for a customer using their saved payment method.
        This is considered an "off-session" payment.
        """
        try:
            intent = stripe.PaymentIntent.create(
                amount=amount,
                currency=currency,
                customer=customer_id,
                payment_method=payment_method_id,
                off_session=True,
                confirm=True,
            )
            return {"status": intent.status, "payment_intent_id": intent.id}
        except stripe.error.CardError as e:
            return {"error": e.user_message or str(e)}
        except stripe.error.StripeError as e:
            return {"error": str(e)}

    def _issue_refund(self, payment_intent_id: str):
        """
        Issues a full refund for a given Payment Intent.
        """
        try:
            stripe.Refund.create(payment_intent=payment_intent_id)
            print(f"Successfully issued refund for Payment Intent: {payment_intent_id}")
        except stripe.error.StripeError as e:
            print(f"CRITICAL ERROR: Failed to issue refund for {payment_intent_id}. Error: {e}")


    def create_transaction(
            self,
            user_id: int,
            transaction_type: TransactionType,
            amount: float,
            description: str = None,
            domain_id: int = None,
            auction_id: int = None,
            listing_id: int = None,
            domain_name_at_purchase: str = None,
            years_purchased: int = None,
            status: str = "COMPLETED",
            db: Session = None
    ):
        """Creates a new transaction record."""
        new_transaction = Transaction(
            user_id=user_id,
            transaction_type=transaction_type,
            amount=amount,
            description=description,
            domain_id=domain_id,
            auction_id=auction_id,
            listing_id=listing_id,
            domain_name_at_purchase=domain_name_at_purchase,
            years_purchased=years_purchased,
            status=status
        )
        db.add(new_transaction)
        db.commit()
        db.refresh(new_transaction)
        return new_transaction

    def create_setup_intent(self, username: str, db: Session):
        user = db.query(User).filter(User.username == username).first()
        if not user:
            raise HTTPException(404, "User not found")
        if not user.stripe_customer_id:
            customer = stripe.Customer.create(email=user.email, name=user.username)
            user.stripe_customer_id = customer.id
            db.commit()

            #####for testing purpose only #####
        pm = stripe.PaymentMethod.create(
            type="card",
            card={"token": "tok_visa"}
        )
        print(pm.id)


        setup_intent = stripe.SetupIntent.create(
            customer=user.stripe_customer_id,
            payment_method_types=["card"]
        )
        return {"client_secret": setup_intent.client_secret}

    def save_payment_method(self, username: str, payment_method_id: str, db: Session):
        user = db.query(User).filter(User.username == username).first()
        if not user:
            raise HTTPException(404, "User not found")

        stripe.PaymentMethod.attach(payment_method_id, customer=user.stripe_customer_id)
        stripe.Customer.modify(user.stripe_customer_id, invoice_settings={"default_payment_method": payment_method_id})

        user.stripe_payment_method_id = payment_method_id
        db.commit()
        return {"message": "Payment method saved"}

    def get_payment_info(self, username: str, db: Session):
        user = db.query(User).filter(User.username == username).first()
        if not user:
            raise HTTPException(404, "User not found")

        return {
            "username": user.username,
            "stripe_customer_id": user.stripe_customer_id,
            "stripe_payment_method_id": user.stripe_payment_method_id,
        }

    def remove_payment_method(self, username: str, db: Session):
        user = db.query(User).filter(User.username == username).first()
        if not user:
            raise HTTPException(404, "User not found")

        if not user.stripe_payment_method_id:
            raise HTTPException(400, "No payment method to remove")

        try:
            stripe.PaymentMethod.detach(user.stripe_payment_method_id)
            user.stripe_payment_method_id = None
            db.commit()

            return {"message": "Payment method removed successfully"}
        except stripe.error.StripeError as e:
            raise HTTPException(400, str(e))

===== utils\__init__.py =====


===== utils\utils.py =====
import requests


def convert_usd_to_cad(usd_amount):
    """Converts USD to CAD using exchange rate API."""
    url = "https://v6.exchangerate-api.com/v6/6cdeb5d9db93fcb735409cb5/latest/USD"

    try:
        response = requests.get(url)
        data = response.json()

        if data["result"] == "success":
            exchange_rate = data["conversion_rates"]["CAD"]
            cad_amount = usd_amount * exchange_rate
            return round(cad_amount, 2)
        else:
            print("Error fetching exchange rates.")
            return None
    except requests.exceptions.RequestException as e:
        print(f"Network error: {e}")
        return None

def generate_similar_domains(base_name):
    """Generate similar domain suggestions based on the base name."""
    tlds = ['com', 'net', 'org', 'io', 'co', 'app', 'dev', 'ai', 'xyz', 'tech']

    prefixes = ['my', 'get', 'the', 'try']
    suffixes = ['app', 'hub', 'pro', 'site', 'web', 'online']

    suggestions = []

    for tld in tlds:
        suggestions.append(f"{base_name}.{tld}")
    for prefix in prefixes:
        suggestions.append(f"{prefix}{base_name}.com")
    for suffix in suffixes:
        suggestions.append(f"{base_name}{suffix}.com")

    return list(set(suggestions))

if __name__ == "__main__":
    usd_value = 100
    cad_value = convert_usd_to_cad(usd_value)

    if cad_value is not None:
        print(f"{usd_value} USD is equal to {cad_value:.2f} CAD")
    else:
        print("Currency conversion failed.")


